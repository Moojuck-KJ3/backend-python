import pandas as pd
import numpy as np
from sklearn.manifold import TSNE
from sklearn.metrics.pairwise import cosine_similarity
from ast import literal_eval

# CSV 파일 불러오기
file_path = 'formatted_output_file.csv'
df = pd.read_csv(file_path)

# 'vectors' 컬럼의 값을 파이썬 리스트로 변환
df['vector'] = df['vector'].apply(lambda x: literal_eval(x) if pd.notna(x) else np.nan)

# Drop rows with NaN values in the 'vector' column
df = df.dropna(subset=['vector'])

# 벡터 A와 벡터 B 정의 (원하는 값으로 수정)
vector_a = np.array([-0.07297646, 0.12071797, -0.0064895, -0.02885444, -0.07191824, -0.23938583, 0.1205702, 0.28717396, -0.05089436, -0.10364026, -0.08778783, -0.13529828, -0.09268506, 0.04054192, 0.0050529, -0.03308116, -0.10161997, -0.1617182, 0.00152157, -0.23443541, 0.05722535, -0.01119028, 0.00056987, -0.01927815, -0.09923378, -0.02320454, -0.1109204, -0.01287305, -0.23765239, 0.05684413, 0.09819515, -0.06924028, -0.05051826, -0.15280773, -0.11599071, 0.19673303, 0.0797915, 0.16014232, -0.02927016, -0.1175392, -0.05471098, -0.0331287, -0.21998602, -0.00390798, 0.03100042, -0.22998394, -0.1070547, 0.05905624, 0.07459295, 0.2685322, 0.11366019, -0.27367148, -0.1594044, 0.01244664, 0.01600293, 0.18469152, 0.08765821, 0.12040072, -0.04551543, 0.00188111, -0.02017423, -0.01017176, -0.12510951, 0.04154972, -0.19167395, 0.06142982, -0.07244893, 0.1039491, -0.04799514, 0.12106445, 0.04307477, 0.19566713, 0.14844488, -0.13226421, -0.00253427, 0.20737062, -0.00462821, 0.00351328, -0.12613447, -0.01350448, -0.23310359, 0.08365773, -0.11006566, 0.2602537, -0.11823194, -0.10197666, -0.08054134, 0.18280835, 0.16859709, 0.02593065, 0.14984939, -0.06036462, 0.09453917, 0.08687375, 0.1604603, 0.18000174, 0.157636, -0.11307137, 0.08851541, -0.10222807])
vector_b = np.array([-0.11628088, 0.7218094, -0.36502776, -0.11095455, -0.5541897, -0.96934235, 1.1457703, 1.325946, -0.6312145, -0.43125716, -0.4551485, -1.1863332, -0.2100964, -0.2145145, 0.27461705, -0.3432854, -0.24282844, -1.1008028, -0.29571107, -1.7754197, 0.25778005, -0.05998318, -0.2101075, -0.6970369, -1.2705286, -0.10279843, -0.3432006, -0.09928922, -1.9896411, 0.01430126, 0.81089735, -0.5639558, 0.03826561, -0.48809224, -1.0630807, 1.0079755, 0.327069, 1.5255381, -0.8029971, -0.29004422, -0.54926527, -0.09152619, -0.75375724, 0.360515, 0.12068564, -1.0196347, -0.56036794, 0.5117742, 0.56272584, 1.1619897, 0.20578042, -1.4901164, -0.25712812, -0.15198892, -0.17581628, 1.7867888, 0.8435258, 1.4424788, -0.14606301, 0.2191275, 0.2957184, -0.4224227, -1.1442468, 0.24373981, -1.0074017, 0.42888886, -0.79650074, 0.83125097, 0.19707178, 0.5419316, -0.04121738, 1.4526975, 1.0881368, -0.17969072, -0.03053693, 1.4482554, 0.62988544, 0.12270778, -1.1303165, -0.25334033, -1.7929882, 1.1139368, -1.2291907, 1.2407342, -0.09166646, -0.34728137, -1.0992924, 0.9236238, 1.2859838, -0.43115598, 0.65506035, -0.22614422, -0.2766154, 0.69824374, 1.0748429, 0.7339759, 0.3924532, -0.1116314, 0.8894173, -1.2526354])

# T-SNE를 사용하여 차원 축소
def perform_tsne(vectors):
    tsne = TSNE(n_components=2, random_state=42, perplexity=1)
    tsne_result = tsne.fit_transform(vectors)
    return tsne_result

# 'vectors' 컬럼의 각 벡터를 T-SNE를 사용하여 차원 축소
non_empty_vectors = np.array(df['vector'].tolist())
all_vectors = np.vstack([vector_a, vector_b, non_empty_vectors]) if non_empty_vectors.shape[0] > 0 else np.vstack([vector_a, vector_b])
tsne_result = perform_tsne(all_vectors)

# 벡터 A와 벡터 B의 차원 축소된 좌표
tsne_coord_a = tsne_result[0]
tsne_coord_b = tsne_result[1]

# 차원 축소된 좌표에서 벡터 A와 벡터 B 사이의 거리 계산
def euclidean_distance(coord_a, coord_b):
    return np.sqrt(np.sum((coord_a - coord_b) ** 2))

# 벡터 A와 벡터 B 사이의 거리
distance_ab = euclidean_distance(tsne_coord_a, tsne_coord_b)

# 거리가 일정 범위 이내인 벡터들 선택
selected_vectors = df[df['vector'].apply(lambda x: euclidean_distance(tsne_result[2], perform_tsne(np.vstack([vector_a, vector_b, np.array(x)]))) < distance_ab)]

# 선택된 벡터들 출력
print('selected_vectors:', selected_vectors)
